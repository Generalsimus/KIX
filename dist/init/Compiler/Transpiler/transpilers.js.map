{"version":3,"file":"transpilers.js","sourceRoot":"","sources":["../../../../init/Compiler/Transpiler/transpilers.js"],"names":[],"mappings":"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","sourcesContent":["import ts, { factory, visitEachChild, getDirectoryPath, normalizeSlashes, SyntaxKind, getLocalNameForExternalImport, collectExternalModuleInfo } from \"typescript\"\r\nimport { generateFactory } from \"./createFactoryCode\"\r\nimport resolve from 'resolve'\r\nimport path from \"path/posix\"\r\nimport chokidar from \"chokidar\"\r\nimport { getColumnName } from \"../../../Helpers/utils\"\r\nimport { configModules, ModulesThree } from \"./utils\"\r\n\r\n\r\nconst { createStringLiteral } = factory\r\nconst {\r\n    CREATE_Export_File_Function,\r\n    CREATE_Plus_Token_Nodes,\r\n    CREATE_Const_Variable,\r\n    CREATE_Property_Access_Expression\r\n} = generateFactory\r\n\r\n\r\n\r\nconst watcher = chokidar.watch([]);\r\n// let STATEMENTS = []\r\n// let stateNode = CREATE_Call_Function(STATEMENTS)\r\n// let UNICNAME = ts.createUniqueName('AAA')\r\n\r\nexport const transpilerBefore = {\r\n    // [SyntaxKind.ExportAssignment]: (Node) => {  \r\n    // }, \r\n    // [SyntaxKind.ArrowFunction]: (NODE, visitor, CTX) => { \r\n    //     // return visitEachChild(NODE, visitor, CTX)\r\n    // },\r\n\r\n    [SyntaxKind.ImportKeyword]: (NODE, visitor, CTX) => {\r\n        //     console.log(\"🚀 ---> file: transpilers.js ---> line 31 ---> CTX\",)\r\n        if (NODE.parent.arguments) {\r\n            NODE.parent.arguments[0] = CREATE_Plus_Token_Nodes([createStringLiteral(CTX.getCompilerOptions().__Url_Dir_Path), NODE.parent.arguments[0]])\r\n        }\r\n        return ts.createIdentifier(\"ASYNC_IMPORT_POLYFIL\")\r\n    },\r\n    [SyntaxKind.RequireKeyword]: (NODE, visitor, CTX) => {\r\n        return ts.createIdentifier(\"ssssssssssssss\")\r\n    },\r\n    // [SyntaxKind.CallExpression]: (NODE, visitor, CTX) => {\r\n    // console.log(\"🚀 ---> file: transpilers.js ---> line 43 ---> NODE\", NODE.expression.escapedText)\r\n    //     return ts.createIdentifier(\"ssssssssssssss\")\r\n    // },\r\n\r\n    // [SyntaxKind.ExportAssignment]: (NODE, visitor, CTX) => { \r\n    //     // return visitEachChild(NODE, visitor, CTX)\r\n    // },\r\n\r\n    [SyntaxKind.SourceFile]: (NODE, visitor, CTX) => {\r\n        if (NODE.before_visited) return NODE\r\n\r\n        const compilerOptions = CTX.getCompilerOptions()\r\n        const ModuleColection = CTX.ModuleColection = configModules(NODE, compilerOptions)\r\n        if (NODE.imports.length) {\r\n            const { externalImports } = collectExternalModuleInfo(CTX, NODE, CTX.getEmitResolver(), compilerOptions);\r\n            externalImports.length && NODE.statements.splice(0, 0, CREATE_Const_Variable(externalImports.map((importNode) => {\r\n                const { Module_INDEX } = ModuleColection[importNode.moduleSpecifier.text]\r\n\r\n\r\n                return [\r\n                    getLocalNameForExternalImport(factory, importNode, NODE),\r\n                    CREATE_Property_Access_Expression([compilerOptions.__Import_Module_Name, getColumnName(Module_INDEX)])\r\n                ]\r\n            })))\r\n        }\r\n\r\n\r\n        NODE.before_visited = true;\r\n        return visitEachChild(NODE, visitor, CTX)\r\n    }\r\n}\r\n\r\n\r\nexport const transpilerAfter = {\r\n    [SyntaxKind.SourceFile]: (NODE, visitor, CTX) => {\r\n        if (NODE.After_visited) return NODE\r\n        const moduleInfo = ModulesThree.get(NODE.originalFileName)\r\n\r\n        if (moduleInfo.KindName === \"ImportKeyword\") {\r\n            // სინქქრონული მოდულის იმპორტი\r\n            // NODE.statements = []\r\n        }\r\n        try {\r\n\r\n\r\n            const newStatements = NODE.statements[0].expression.arguments.pop().body.statements\r\n\r\n            NODE.statements = [CREATE_Export_File_Function(newStatements, moduleInfo.Module_INDEX, CTX.getCompilerOptions().__Import_Module_Name)]\r\n        } catch (error) {\r\n\r\n        }\r\n\r\n        NODE.After_visited = true;\r\n        return NODE\r\n    }\r\n}"]}